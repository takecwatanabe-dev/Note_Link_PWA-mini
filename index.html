<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Note Link mini – v0.7.0 (mini-fix21-toolbar-restore) / 2025-09-22 08:05 JST</title>
<style>
:root{
  --ink:#e6f1ff; --ink-dim:#a8b5cc;
  --bg:#0b0f1a; --paper:#0c1220; --panel:#101828;
  --accent:#4f7cff; --accent-weak:#2a54ff44;
  --ok:#20e3c2; --ok-weak:#20e3c280;
  --danger:#ff5a7a;
  --topbar-h:44px; --toolbar-w:64px;
  --tool-size:44px;         /* fix21相当の大きさ */
  --tool-radius:12px;
}
html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Meiryo",sans-serif}
*,*:before,*:after{box-sizing:border-box}
*{writing-mode:horizontal-tb}

/* ===== Top bar ===== */
header.topbar{
  position:sticky; top:0; left:0; right:0; z-index:100;
  height:var(--topbar-h);
  display:flex; align-items:center; gap:8px; padding:6px 10px;
  background:linear-gradient(180deg,var(--accent-weak),#18244a);
  border-bottom:1px solid rgba(255,255,255,.08);
}
.btn{height:28px;padding:0 10px;border-radius:10px;font-size:12px;
  display:inline-flex;align-items:center;justify-content:center;
  color:var(--ink);background:rgba(255,255,255,.12);
  border:1px solid rgba(255,255,255,.18); user-select:none; cursor:pointer}
.btn:active{transform:translateY(1px)}

/* ===== Layout ===== */
#wrap{position:relative}
#stage{position:absolute; inset:0; top:var(--topbar-h); padding-left:var(--toolbar-w); overflow:hidden}
#vp{position:absolute; inset:0; transform-origin:0 0}
canvas{position:absolute; left:0; top:0; display:block}
#grid{z-index:0} #paper{z-index:1}

/* ===== Sidebar / Tools (fix21の見た目と挙動) ===== */
aside.toolbar{
  position:absolute; top:var(--topbar-h); left:0; bottom:0; z-index:90;
  width:var(--toolbar-w); padding:8px 6px;
  background:rgba(0,0,0,.28); box-shadow:inset 0 0 0 1px rgba(255,255,255,.06);
}
.fold{position:absolute; top:8px; left:12px}
.tool{
  width:var(--tool-size); height:var(--tool-size);
  margin:0 auto 8px; border-radius:var(--tool-radius);
  display:grid; place-items:center; color:#fff;
  background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.16);
  outline:3px solid transparent; transition:outline-color .12s ease, outline-width .12s ease;
  user-select:none; cursor:pointer;
}
.tool svg{width:22px; height:22px}
.tool.active{outline-color:var(--ok); outline-width:3px}     /* ツール＝太め */
.tool.gear.active{outline-color:var(--ok); outline-width:2px} /* ⚙だけ細め */

.tri{width:18px;height:18px;display:block}
.tri path{stroke:#fff;stroke-width:2;fill:none}
.fold[data-collapsed="true"] ~ .stack{display:none}
.fold[data-collapsed="true"] .tri{transform:rotate(180deg)}
.stack{position:absolute; top:56px; left:0; right:0}

/* ===== 設定パネル ===== */
.panel{
  position:absolute; left:76px; top:72px; min-width:320px; max-width:420px;
  background:var(--panel); border:1px solid rgba(255,255,255,.12);
  border-radius:12px; box-shadow:0 16px 40px rgba(0,0,0,.5);
  padding:14px; display:none; z-index:110;
}
.panel.show{display:block}
.panel .drag{position:absolute; left:10px; top:10px; width:24px; height:24px; display:grid; place-items:center; cursor:grab}
.panel .drag:active{cursor:grabbing}
.panel .drag svg{width:16px;height:16px;opacity:.7}
.panel .close{position:absolute; right:10px; top:10px; height:26px; padding:0 10px; border-radius:8px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08); color:#fff}
.row{display:flex; align-items:center; gap:10px; margin:10px 0}
.row label{width:92px; font-size:12px; color:var(--ink-dim)}
.row input[type="range"]{flex:1}
.inline{display:inline-flex; align-items:center; gap:8px}
.hint{font-size:12px; color:var(--ink-dim)}

/* HUD（角度表示） */
#hud{position:absolute; pointer-events:none; z-index:120; color:#fff; font-size:11px; padding:2px 6px; border-radius:8px; background:rgba(0,0,0,.45); display:none}
</style>
</head>
<body>
<header class="topbar" id="topbar">
  <span style="opacity:.7;font-size:12px">Note Link v0.7.0 / No.13 · build: mini-fix21-toolbar-restore</span>
  <span style="flex:1"></span>
  <button class="btn" id="zoomOut">−</button>
  <button class="btn" id="zoomReset">100%</button>
  <button class="btn" id="zoomIn">＋</button>
  <button class="btn" id="undoBtn">undo</button>
  <button class="btn" id="redoBtn">redo</button>
  <button class="btn" id="printBtn">印刷</button>
  <button class="btn" id="pngBtn">PNG</button>
  <button class="btn" id="shareBtn">共有</button>
</header>

<div id="wrap">
  <aside class="toolbar" id="toolbar">
    <div class="fold" id="fold">
      <div class="tool" title="折りたたみ">
        <svg class="tri" viewBox="0 0 24 24"><path d="M5 15L12 8l7 7"/></svg>
      </div>
    </div>
    <div class="stack" id="toolStack">
      <div class="tool active" id="t-pen" title="ペン">
        <svg viewBox="0 0 24 24"><path d="M3 21l3.5-.7L19 7.8 16.2 5 4.7 16.5 4 20zM14 6l4 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      </div>
      <div class="tool" id="t-marker" title="マーカー">
        <svg viewBox="0 0 24 24"><path d="M5 15l9-9 4 4-9 9-5 1 1-5z" fill="currentColor"/></svg>
      </div>
      <div class="tool" id="t-eraser" title="消しゴム">
        <svg viewBox="0 0 24 24"><path d="M6 19h12M3 14l8-8a2 2 0 012.8 0l4.2 4.2a2 2 0 010 2.8l-8 8H7.8a2 2 0 01-1.4-.6L3.6 16a2 2 0 010-2.8z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      </div>
      <div class="tool" id="t-hand" title="選択/パン">
        <svg viewBox="0 0 24 24"><path d="M8 13V7a1 1 0 012 0v4m2 2V5a1 1 0 012 0v8m2-2V7a1 1 0 012 0v6m-8 3l-1 5h8l4-8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      </div>
      <div class="tool" id="t-text" title="テキスト（keyboard）">
        <svg viewBox="0 0 24 24"><rect x="3" y="7" width="18" height="10" rx="2" fill="none" stroke="currentColor" stroke-width="2"/><path d="M6 10h2M10 10h2M14 10h2M6 13h8M16 13h2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      </div>
      <div class="tool gear" id="t-gear" title="設定（今のツール）">
        <svg viewBox="0 0 24 24"><path d="M12 15.5a3.5 3.5 0 110-7 3.5 3.5 0 010 7z" stroke="currentColor" stroke-width="2" fill="none"/><path d="M19 12a7 7 0 01-.1 1.2l2 1.6-2 3.5-2.3-.9a7.2 7.2 0 01-2 .9L14 22h-4l-.6-2.8a7.2 7.2 0 01-2-.9l-2.3.9-2-3.5 2-1.6A7 7 0 015 12c0-.4 0-.8.1-1.2l-2-1.6 2-3.5 2.3.9a7.2 7.2 0 012-.9L10 2h4l.6 2.8a7.2 7.2 0 012 .9l2.3-.9 2 3.5-2 1.6c.1.4.1.8.1 1.2z" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </div>
    </div>
  </aside>

  <main id="stage">
    <div id="vp">
      <canvas id="grid"></canvas>
      <canvas id="paper"></canvas>
      <div id="hud">0°</div>
    </div>
  </main>
</div>

<!-- 設定パネル（コンテンツはJSで切替） -->
<div class="panel" id="panel">
  <button class="drag" id="pDrag" title="ドラッグで移動">
    <svg viewBox="0 0 24 24"><path d="M4 9h16M4 15h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
  </button>
  <button class="close" id="pClose">閉じる</button>
  <div id="panelBody"></div>
</div>

<script>
/* =========================
   build: mini-fix21-toolbar-restore / 2025-09-22 08:05 JST
   目的：ツールバー挙動・設定の出し分けを fix21 と同等に戻す
========================= */

const $=s=>document.querySelector(s);
const topbar=$('#topbar'), stage=$('#stage'), vp=$('#vp'), hud=$('#hud');
const cg=$('#grid'), cv=$('#paper'), gtx=cg.getContext('2d'), ctx=cv.getContext('2d',{alpha:false,desynchronized:true});
let dpr=Math.max(1,Math.floor(devicePixelRatio||1)), zoom=1, panX=0, panY=0;

function measureTop(){ const r=topbar.getBoundingClientRect(); document.documentElement.style.setProperty('--topbar-h', r.height+'px'); }
addEventListener('resize',measureTop); addEventListener('orientationchange',measureTop); measureTop();

function fit(){
  const r=stage.getBoundingClientRect();
  [cg,cv].forEach(c=>{
    c.width = Math.max(1,Math.floor(r.width*dpr));
    c.height= Math.max(1,Math.floor(r.height*dpr));
    c.style.width=r.width+'px'; c.style.height=r.height+'px';
  });
  vp.style.transform=`translate(${panX}px,${panY}px) scale(${zoom})`;
  ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--paper')||'#0c1220'; ctx.fillRect(0,0,r.width,r.height);
  drawGrid();
}
new ResizeObserver(fit).observe(stage);

/* ===== ツール状態 / 設定保存 ===== */
let tool='pen';
const toolBtns=['t-pen','t-marker','t-eraser','t-hand','t-text','t-gear'];
toolBtns.forEach(id=>{
  $('#'+id).addEventListener('click',()=>{
    if(id==='t-gear'){ openPanel(); return; }
    tool = id.replace('t-','');
    setActiveTool(id);
    closePanel();
    saveLastTool();
  });
});
function setActiveTool(id){
  toolBtns.forEach(x=>$('#'+x).classList.remove('active'));
  $('#'+id).classList.add('active');
}
function saveLastTool(){ localStorage.setItem('nl_lastTool', tool); }
function restoreLastTool(){ const t=localStorage.getItem('nl_lastTool'); if(t && toolBtns.includes('t-'+t)){ tool=t; setActiveTool('t-'+t);} }
restoreLastTool();

/* 折り畳み */
$('#fold').addEventListener('click',e=>{
  if(!e.target.closest('.tool')) return;
  const folded = $('#fold').hasAttribute('data-folded');
  if(folded){ $('#fold').removeAttribute('data-folded'); }
  else { $('#fold').setAttribute('data-folded',''); }
});

/* ===== 設定保持（ツール別） ===== */
const defaults={
  pen:{color:'#cfe9ff', size:4, alpha:100, line:false, gridShow:false, gridStep:10},
  marker:{color:'#b6d06a', size:16, alpha:40, cap:'butt', line:false, gridShow:false, gridStep:10},
  eraser:{size:24},
  hand:{}, text:{color:'#ffffff', size:48, bold:false, italic:false, gridShow:false, gridStep:10}
};
let conf=JSON.parse(localStorage.getItem('nl_conf')||'{}');
function cfg(t){ if(!conf[t]) conf[t]=JSON.parse(JSON.stringify(defaults[t]||{})); return conf[t]; }
function saveConf(){ localStorage.setItem('nl_conf', JSON.stringify(conf)); }

/* ===== パネル（内容をツールごとに生成） ===== */
const panel=$('#panel'), panelBody=$('#panelBody');
function openPanel(){
  $('#t-gear').classList.add('active'); // ⚙も緑化
  buildPanel();
  panel.classList.add('show');
}
function closePanel(){ $('#t-gear').classList.remove('active'); panel.classList.remove('show'); }
$('#pClose').onclick=closePanel;

/* ドラッグで移動（≡ハンドル） */
(()=>{
  const drag=$('#pDrag'); let dragging=false, sx=0, sy=0, ox=0, oy=0;
  drag.addEventListener('pointerdown',e=>{ dragging=true; sx=e.clientX; sy=e.clientY; const r=panel.getBoundingClientRect(); ox=r.left; oy=r.top; drag.setPointerCapture(e.pointerId); });
  drag.addEventListener('pointermove',e=>{ if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy; panel.style.left=(ox+dx)+'px'; panel.style.top=(oy+dy)+'px'; });
  drag.addEventListener('pointerup',()=>dragging=false);
})();

function row(label, html){ return `<div class="row"><label>${label}</label>${html}</div>`; }
function buildPanel(){
  const c=cfg(tool);
  if(tool==='pen'){
    panelBody.innerHTML=
      row('色', `<input type="color" id="penColor" value="${c.color}">`) +
      row('太さ', `<input type="range" id="penSize" min="1" max="40" value="${c.size}"><span class="hint" id="penSizeV">${c.size}px</span>`) +
      row('不透明度', `<input type="range" id="penAlpha" min="5" max="100" value="${c.alpha}"><span class="hint" id="penAlphaV">${c.alpha}%</span>`) +
      row('直線', `<label class="inline"><input type="checkbox" id="penLine" ${c.line?'checked':''}> 直線モード（15°刻み / モバイル）</label>`) +
      row('グリッド', `<label class="inline"><input type="checkbox" id="gShow" ${c.gridShow?'checked':''}> 表示</label> <select id="gStep"><option value="5"${c.gridStep==5?' selected':''}>5mm</option><option value="10"${c.gridStep==10?' selected':''}>10mm</option></select>`);
  }
  else if(tool==='marker'){
    panelBody.innerHTML=
      row('色', `<input type="color" id="mkColor" value="${c.color}">`) +
      row('太さ', `<input type="range" id="mkSize" min="4" max="64" value="${c.size}"><span class="hint" id="mkSizeV">${c.size}px</span>`) +
      row('不透明度', `<input type="range" id="mkAlpha" min="5" max="100" value="${c.alpha}"><span class="hint" id="mkAlphaV">${c.alpha}%</span>`) +
      row('端の形', `<select id="mkCap"><option value="butt"${c.cap==='butt'?' selected':''}>□ 角</option><option value="round"${c.cap==='round'?' selected':''}>● 丸</option></select>`) +
      row('直線', `<label class="inline"><input type="checkbox" id="mkLine" ${c.line?'checked':''}> 直線モード</label>`) +
      row('グリッド', `<label class="inline"><input type="checkbox" id="gShow" ${c.gridShow?'checked':''}> 表示</label> <select id="gStep"><option value="5"${c.gridStep==5?' selected':''}>5mm</option><option value="10"${c.gridStep==10?' selected':''}>10mm</option></select>`);
  }
  else if(tool==='eraser'){
    panelBody.innerHTML=
      row('消し幅', `<input type="range" id="erSize" min="6" max="72" value="${c.size}"><span class="hint" id="erSizeV">${c.size}px</span>`) +
      `<div class="hint" style="margin-top:6px">※ fix21仕様：モードは「こする」固定（βの一筆削除は後続で）</div>`;
  }
  else if(tool==='hand'){
    panelBody.innerHTML=`<div class="row"><label>操作</label><div class="hint">ドラッグでキャンバスを移動（パン）/ ホイールでズーム</div></div>`;
  }
  else if(tool==='text'){
    panelBody.innerHTML=
      row('色', `<input type="color" id="txColor" value="${c.color}">`) +
      row('文字サイズ', `<input type="range" id="txSize" min="12" max="96" value="${c.size}"><span class="hint" id="txSizeV">${c.size}px</span>`) +
      row('テキスト', `<div class="inline"><button class="btn" id="txAdd">テキストを追加</button><button class="btn" id="txBold">太字</button><button class="btn" id="txItalic">斜体</button><button class="btn" id="txDel">選択削除</button><button class="btn" id="txKill">枠ごと削除</button></div>`) +
      row('グリッド', `<label class="inline"><input type="checkbox" id="gShow" ${c.gridShow?'checked':''}> 表示</label> <select id="gStep"><option value="5"${c.gridStep==5?' selected':''}>5mm</option><option value="10"${c.gridStep==10?' selected':''}>10mm</option></select>`);
  }
  bindPanelEvents();
}

/* パネルのイベント → confへ反映して保存、必要に応じて再描画 */
function bindPanelEvents(){
  const c=cfg(tool);
  const by=(id)=>panelBody.querySelector('#'+id);

  if(tool==='pen'){
    by('penColor').oninput=e=>{c.color=e.target.value; saveConf();}
    by('penSize').oninput=e=>{c.size=+e.target.value; by('penSizeV').textContent=c.size+'px'; saveConf();}
    by('penAlpha').oninput=e=>{c.alpha=+e.target.value; by('penAlphaV').textContent=c.alpha+'%'; saveConf();}
    by('penLine').oninput=e=>{c.line=e.target.checked; saveConf();}
    by('gShow').oninput=e=>{c.gridShow=e.target.checked; drawGrid(); saveConf();}
    by('gStep').oninput=e=>{c.gridStep=+e.target.value; drawGrid(); saveConf();}
  }else if(tool==='marker'){
    by('mkColor').oninput=e=>{c.color=e.target.value; saveConf();}
    by('mkSize').oninput=e=>{c.size=+e.target.value; by('mkSizeV').textContent=c.size+'px'; saveConf();}
    by('mkAlpha').oninput=e=>{c.alpha=+e.target.value; by('mkAlphaV').textContent=c.alpha+'%'; saveConf();}
    by('mkCap').oninput=e=>{c.cap=e.target.value; saveConf();}
    by('mkLine').oninput=e=>{c.line=e.target.checked; saveConf();}
    by('gShow').oninput=e=>{c.gridShow=e.target.checked; drawGrid(); saveConf();}
    by('gStep').oninput=e=>{c.gridStep=+e.target.value; drawGrid(); saveConf();}
  }else if(tool==='eraser'){
    by('erSize').oninput=e=>{c.size=+e.target.value; by('erSizeV').textContent=c.size+'px'; saveConf();}
  }else if(tool==='text'){
    by('txColor').oninput=e=>{c.color=e.target.value; updateSelectedTextStyle(); saveConf();}
    by('txSize').oninput=e=>{c.size=+e.target.value; by('txSizeV').textContent=c.size+'px'; updateSelectedTextStyle(); saveConf();}
    by('txAdd').onclick=()=>addText();
    by('txBold').onclick=()=>toggleSelFmt('fontWeight','bold');
    by('txItalic').onclick=()=>toggleSelFmt('fontStyle','italic');
    by('txDel').onclick=()=>deleteSelectedText();
    by('txKill').onclick=()=>deleteSelectedFrame();
    by('gShow').oninput=e=>{c.gridShow=e.target.checked; drawGrid(); saveConf();}
    by('gStep').oninput=e=>{c.gridStep=+e.target.value; drawGrid(); saveConf();}
  }
}

/* ===== グリッド ===== */
function mm2px(mm){ return mm*3.78 } // 96dpi基準
function drawGrid(){
  const r=stage.getBoundingClientRect();
  gtx.setTransform(1,0,0,1,0,0); gtx.scale(dpr,dpr);
  gtx.clearRect(0,0,r.width,r.height);
  const cs = cfg(tool); // 今のツールのグリッド表示状態を使う（fix21）
  const show = cs.gridShow, stepMM=cs.gridStep||10;
  if(!show) return;
  const step = mm2px(stepMM)*zoom;
  gtx.beginPath(); gtx.strokeStyle='rgba(255,255,255,.08)'; gtx.lineWidth=1;
  for(let x=0; x<=r.width; x+=step){ gtx.moveTo(x,0); gtx.lineTo(x,r.height); }
  for(let y=0; y<=r.height; y+=step){ gtx.moveTo(0,y); gtx.lineTo(r.width,y); }
  gtx.stroke();
}

/* ===== 描画（直線HUD／モバイル直線モード） ===== */
let drawing=false, last=null, shift=false;
addEventListener('keydown',e=>{ if(e.key==='Shift') shift=true;});
addEventListener('keyup',e=>{ if(e.key==='Shift') shift=false;});

function pos(e){
  const r=cv.getBoundingClientRect();
  return {x:(e.clientX-r.left)/zoom, y:(e.clientY-r.top)/zoom};
}
function setStrokeForTool(){
  ctx.lineJoin='round';
  if(tool==='pen'){
    const c=cfg('pen'); ctx.globalCompositeOperation='source-over';
    ctx.strokeStyle=c.color; ctx.lineWidth=c.size; ctx.globalAlpha=c.alpha/100;
    ctx.lineCap='round';
  }else if(tool==='marker'){
    const c=cfg('marker'); ctx.globalCompositeOperation='source-over';
    ctx.strokeStyle=c.color; ctx.lineWidth=c.size; ctx.globalAlpha=c.alpha/100;
    ctx.lineCap=c.cap||'butt';
  }else if(tool==='eraser'){
    const c=cfg('eraser'); ctx.globalCompositeOperation='destination-out';
    ctx.strokeStyle='#000'; ctx.lineWidth=c.size;
    ctx.lineCap='round'; ctx.globalAlpha=1;
  }else{
    ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=1;
  }
}
function showHUD(x,y,deg){ hud.style.display='block'; hud.style.left=(x+12)+'px'; hud.style.top=(y+12)+'px'; hud.textContent=`${deg|0}°`; }
function hideHUD(){ hud.style.display='none'; }

cv.addEventListener('pointerdown',e=>{
  if(tool==='hand'){ // パン（簡易）
    panStart(e); return;
  }
  if(['pen','marker','eraser'].includes(tool)){
    cv.setPointerCapture?.(e.pointerId);
    drawing=true; last=pos(e); setStrokeForTool();
  }
});
cv.addEventListener('pointermove',e=>{
  if(panning){ panMove(e); return; }
  if(!drawing) return;
  const p=pos(e); const isLine = (tool==='pen'?cfg('pen').line:tool==='marker'?cfg('marker').line:false) || shift;
  ctx.beginPath(); ctx.moveTo(last.x,last.y);
  if(isLine){
    ctx.lineTo(p.x,p.y);
    const rad=Math.atan2(p.y-last.y,p.x-last.x); const deg=rad*180/Math.PI;
    showHUD(e.clientX,e.clientY, Math.round(deg/15)*15);
  }else{
    ctx.lineTo(p.x,p.y); last=p; hideHUD();
  }
  ctx.stroke();
});
cv.addEventListener('pointerup',()=>{
  if(panning){ panEnd(); return; }
  if(!drawing) return; drawing=false; hideHUD(); pushHistory(); ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
});

/* ===== パン（Hand） ===== */
let panning=false, psx=0, psy=0, opx=0, opy=0;
function panStart(e){ panning=true; psx=e.clientX; psy=e.clientY; opx=panX; opy=panY; cv.setPointerCapture?.(e.pointerId); }
function panMove(e){ if(!panning) return; panX=opx+(e.clientX-psx); panY=opy+(e.clientY-psy); vp.style.transform=`translate(${panX}px,${panY}px) scale(${zoom})`; }
function panEnd(){ panning=false; }

/* ===== Undo/Redo ===== */
let hist=[], redo=[];
function pushHistory(){
  try{ const data=cv.toDataURL('image/webp',.9); hist.push(data); if(hist.length>10) hist.shift(); redo.length=0; }catch(e){}
}
async function restore(url){
  return new Promise((res,rej)=>{
    const img=new Image(); img.onload=()=>{ const r=stage.getBoundingClientRect(); ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--paper')||'#0c1220'; ctx.fillRect(0,0,r.width,r.height); ctx.drawImage(img,0,0,r.width,r.height); res(); }; img.onerror=rej; img.src=url;
  });
}
$('#undoBtn').onclick=async ()=>{ if(hist.length<=1) return; const cur=hist.pop(); redo.push(cur); await restore(hist[hist.length-1]); };
$('#redoBtn').onclick=async ()=>{ const u=redo.pop(); if(!u) return; await restore(u); hist.push(u); };

/* ===== ズーム & 出力 ===== */
function setZoom(z){ zoom=Math.min(3,Math.max(.5,z)); vp.style.transform=`translate(${panX}px,${panY}px) scale(${zoom})`; drawGrid(); }
$('#zoomOut').onclick=()=>setZoom(zoom-.1);
$('#zoomIn').onclick =()=>setZoom(zoom+.1);
$('#zoomReset').onclick=()=>setZoom(1);

$('#printBtn').onclick=()=>window.print();
$('#pngBtn').onclick =()=>cv.toBlob(b=>{ const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download='note.png'; a.click(); URL.revokeObjectURL(u); },'image/png');
$('#shareBtn').onclick=async ()=>{
  try{
    if(navigator.canShare){ cv.toBlob(async b=>{ const f=new File([b],'note.png',{type:'image/png'}); await navigator.share({files:[f],title:'Note Link'}); },'image/png'); }
    else $('#pngBtn').click();
  }catch(e){}
};

/* ===== テキスト（最小実装：枠追加／選択削除 等） ===== */
let textNodes=[];
function addText(){
  const c=cfg('text');
  const d=document.createElement('div');
  d.contentEditable='true';
  d.textContent='テキスト';
  Object.assign(d.style,{
    position:'absolute', left:'120px', top:'120px', color:c.color, fontSize:c.size+'px',
    fontWeight:c.bold?'700':'400', fontStyle:c.italic?'italic':'normal',
    outline:'2px solid var(--ok)', borderRadius:'8px', padding:'4px 8px', background:'transparent', zIndex:105
  });
  vp.appendChild(d); textNodes.push(d);
  d.focus();
  d.addEventListener('blur', ()=>{ if(d.textContent.trim()===''){ d.remove(); textNodes=textNodes.filter(x=>x!==d);} });
  pushHistory();
}
function getSelText(){ return textNodes.find(n=> document.activeElement===n ); }
function updateSelectedTextStyle(){
  const n=getSelText(); if(!n) return; const c=cfg('text');
  n.style.color=c.color; n.style.fontSize=c.size+'px'; n.style.fontWeight=c.bold?'700':'400'; n.style.fontStyle=c.italic?'italic':'normal';
}
function toggleSelFmt(key,val){ const c=cfg('text'); c[key]=!c[key]; saveConf(); updateSelectedTextStyle(); }
function deleteSelectedText(){ const n=getSelText(); if(!n) return; n.textContent=''; n.blur(); }
function deleteSelectedFrame(){ const n=getSelText(); if(!n) return; n.remove(); textNodes=textNodes.filter(x=>x!==n); pushHistory(); }

/* ===== 初期化 ===== */
fit(); pushHistory(); drawGrid();
</script>
</body>
</html>
