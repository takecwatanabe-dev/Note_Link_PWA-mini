<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Note Link mini – single file</title>
<style>
:root{
  --ink:#e6f1ff;            /* 文字/アイコン色 */
  --ink-dim:#9db6d9;
  --bg:#0b1020;             /* 背景 */
  --panel:#0f1420;          /* パネル */
  --accent:#4f7cff;         /* メインバー */
  --accent-weak:#2a54ff;    /* メインバー下グラデ */
  --ok:#19e4c7;             /* 緑（選択） */
  --muted:#2b334a;          /* 線/枠 */
  --shadow:0 10px 24px rgba(0,0,0,.45);
  --topbar-h:44px;          /* 実計測でJSから更新されます */
  --sidebar-w:48px;
  --sidebar-top:calc(var(--topbar-h) + 0px);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  color:var(--ink);
  background:var(--bg);
  font-family:system-ui, -apple-system, "Segoe UI", Roboto,
   "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
  letter-spacing:.1px;
}

/* ===== Top bar ===== */
.topbar{
  position:sticky; top:0; left:0; right:0; z-index:50;
  height:var(--topbar-h);
  display:flex; align-items:center; gap:8px;
  padding:8px 10px;
  background:linear-gradient(0deg,var(--accent-weak),var(--accent));
  border-bottom:1px solid rgba(255,255,255,.15);
  box-shadow:0 0 0 1px rgba(0,0,0,.2) inset;
}
.topbar .spacer{flex:1}
.btn{
  display:inline-flex; align-items:center; justify-content:center;
  height:28px; padding:0 10px; gap:6px;
  border-radius:10px; border:1px solid rgba(255,255,255,.18);
  background:rgba(255,255,255,.06); color:var(--ink); font-size:12px;
  cursor:pointer; user-select:none;
}
.btn:hover{ outline:2px solid rgba(79,124,255,.35) }
.btn:active{ transform:translateY(1px) }

/* ===== Stage / layers ===== */
#wrap{ position:relative; }
#stage{
  position:absolute; inset:0; top:var(--sidebar-top);
  left:0; right:0; bottom:0;
  overflow:hidden;
}
#stage-inner{
  position:relative; width:100%; height:100%;
  transform-origin:0 0;
}
#grid,#paper,#hud{
  position:absolute; inset:0;
}
#paper{ background:#0c1220; }   /* 背景色はここでだけ塗る */
#hud{ pointer-events:none }

/* ===== Sidebar ===== */
.sidebar{
  position:absolute; top:var(--sidebar-top); left:0; bottom:0; width:var(--sidebar-w);
  display:flex; flex-direction:column; gap:8px; padding:8px;
  background:rgba(0,0,0,.22); border-right:1px solid rgba(255,255,255,.08);
  z-index:60;
}
.tool{
  width:36px; height:36px; border-radius:10px;
  display:grid; place-items:center;
  border:1px solid var(--muted);
  background:rgba(0,0,0,.18); color:var(--ink);
  cursor:pointer; user-select:none;
  transition:.15s;
}
.tool svg{width:18px;height:18px}
.tool:hover{ outline:2px solid rgba(79,124,255,.35) }
.tool.active{ outline:2px solid var(--ok) }                 /* 太めの緑枠 */
.tool.gear.active{ outline:1px solid var(--ok) }            /* ⚙だけ細い枠 */

.collapse{ margin-bottom:4px }

/* ===== Panel (settings) ===== */
.panel{
  position:absolute; left:64px; top:calc(var(--sidebar-top) + 12px); z-index:70;
  min-width:320px; max-width:420px;
  background:rgba(16,19,32,.96); border:1px solid rgba(255,255,255,.12);
  border-radius:12px; box-shadow:var(--shadow); padding:10px; display:none;
}
.panel.show{ display:block }
.panel h4{ margin:0 0 8px 0; font-size:14px; color:var(--ink) }
.row{ display:flex; align-items:center; gap:10px; margin:8px 0 }
.row label{ width:84px; font-size:12px; color:var(--ink-dim) }
input[type="range"]{ flex:1 }
input[type="color"]{
  width:28px; height:22px; padding:0; border:0; background:transparent; cursor:pointer;
}
.panel .handle{ cursor:grab; font:12px/1 monospace; color:#ddd; opacity:.7 }
.panel .close{ position:absolute; right:10px; top:10px; height:26px; padding:0 10px }
.panel .group{ margin:10px 0 6px; font-size:12px; color:#bcd }
.panel .pill{ padding:6px 10px; border-radius:8px; font-size:12px; border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.05); cursor:pointer }

/* HUD angle badge */
#angle{
  position:absolute; padding:4px 8px; border-radius:8px; font-size:12px;
  color:#fff; background:#222a; pointer-events:none; transform:translate(-50%,-150%); display:none
}

/* Writing direction fix for mobile topbar */
.topbar, .topbar *{ writing-mode:horizontal-tb; }

/* Small helper */
.badge{ font-size:11px; opacity:.7; padding-left:4px }
</style>
</head>
<body>

<!-- ===== Top bar ===== -->
<div class="topbar" id="topbar">
  <div>Note Link v0.7.0 / No.13</div>
  <div class="spacer"></div>
  <button class="btn" id="zoomOut">−</button>
  <button class="btn" id="zoomPct">100%</button>
  <button class="btn" id="zoomIn">＋</button>
  <button class="btn" id="undoBtn">undo</button>
  <button class="btn" id="redoBtn">redo</button>
  <button class="btn" id="printBtn">印刷</button>
  <button class="btn" id="pngBtn">PNG</button>
  <button class="btn" id="shareBtn">共有</button>
  <div class="btn">build: single</div>
</div>

<!-- ===== Stage ===== -->
<div id="wrap">
  <!-- Sidebar -->
  <div class="sidebar" id="sidebar">
    <div class="tool collapse" id="collapseBtn" title="折りたたみ">
      <!-- outline三角形（中抜き） -->
      <svg viewBox="0 0 24 24" fill="none"><path d="M5 16h14L12 7 5 16Z" stroke="currentColor" stroke-width="2"/></svg>
    </div>
    <div class="tool active" data-tool="pen" title="ペン" id="tool-pen">
      <svg viewBox="0 0 24 24" fill="none">
        <path d="M4 20l4-1 10-10-3-3L5 16l-1 4Z" stroke="currentColor" stroke-width="2"/>
      </svg>
    </div>
    <div class="tool" data-tool="marker" title="マーカー" id="tool-marker">
      <svg viewBox="0 0 24 24" fill="none">
        <path d="M3 17l4 4 8-8-4-4-8 8Z" stroke="currentColor" stroke-width="2"/>
      </svg>
    </div>
    <div class="tool" data-tool="eraser" title="消しゴム" id="tool-eraser">
      <svg viewBox="0 0 24 24" fill="none">
        <path d="M6 19h10M4 14l7-7 5 5-7 7H4Z" stroke="currentColor" stroke-width="2"/>
      </svg>
    </div>
    <div class="tool" data-tool="hand" title="パン（移動）" id="tool-hand">
      <svg viewBox="0 0 24 24" fill="none">
        <path d="M7 11V7m4 4V5m4 6V6m3 7c0 4-3 6-6 6s-8-3-8-8" stroke="currentColor" stroke-width="2"/>
      </svg>
    </div>
    <div class="tool" data-tool="text" title="テキスト" id="tool-text">
      <!-- キーボードアイコン -->
      <svg viewBox="0 0 24 24" fill="none">
        <rect x="3" y="7" width="18" height="10" rx="2" stroke="currentColor" stroke-width="2"/>
        <path d="M6 10h2m2 0h2m2 0h2M6 13h10" stroke="currentColor" stroke-width="2"/>
      </svg>
    </div>
    <div class="tool gear" id="tool-gear" title="設定">
      <svg viewBox="0 0 24 24" fill="none">
        <path d="M12 8a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm8 4-2 1 0 2 2 1-1 2-2-1-2 1-1-2 1-2-1-2 1-2 2 1 2-1 1 2Z" stroke="#fff" stroke-width="1.8"/>
      </svg>
    </div>
  </div>

  <!-- Drawing area -->
  <div id="stage">
    <div id="stage-inner">
      <canvas id="grid"></canvas>
      <canvas id="paper"></canvas>
      <canvas id="hud"></canvas>
      <div id="angle">0°</div>
      <!-- テキストボックスはここへ追加 -->
      <div id="textLayer" style="position:absolute; inset:0; pointer-events:none;"></div>
    </div>
  </div>

  <!-- Settings panel -->
  <div class="panel" id="panel">
    <div class="row" style="justify-content:space-between;align-items:center;">
      <div class="handle">≡ drag</div>
      <h4 id="panelTitle" style="margin-left:-40px;">ペン設定</h4>
      <button class="btn close" id="panelClose">閉じる</button>
    </div>
    <div id="panelBody"></div>
  </div>
</div>

<script>
/* ========= helpers ========= */
const $ = sel => document.querySelector(sel);
const on = (el,ev,fn,opt)=>el.addEventListener(ev,fn,opt);
const clamp = (v,a,b)=>Math.min(b,Math.max(a,v));

/* ========= elements ========= */
const topbar = $('#topbar');
const grid = $('#grid'), paper = $('#paper'), hud = $('#hud');
const gtx = grid.getContext('2d'), ctx = paper.getContext('2d'), htx = hud.getContext('2d');
const stage = $('#stage'), inner = $('#stage-inner'), textLayer = $('#textLayer');
const sidebar = $('#sidebar');
const angleBadge = $('#angle');

const tools = {
  pen: $('#tool-pen'),
  marker: $('#tool-marker'),
  eraser: $('#tool-eraser'),
  hand: $('#tool-hand'),
  text: $('#tool-text'),
  gear: $('#tool-gear'),
  collapse: $('#collapseBtn'),
};

/* ========= state ========= */
let tool = 'pen';
let zoom = 1;
let dpr = window.devicePixelRatio || 1;
let drawing = false, panning = false, start = null, last = null, shift = false;
let straightPreview = false;
let off = {x:0,y:0}; // pan offset
const hist=[], redoStack=[]; const HIST_MAX=10;

/* per tool configs */
const state = {
  pen:    { color:'#e6f1ff', size:4, alpha:1, line:false },
  marker: { color:'#cfe580', size:16, alpha:.4, line:false, cap:'butt' },
  eraser: { size:18 },
  grid:   { show:false, pitchMM:10, color:'#546489' },
  text:   { size:24, color:'#ffffff', bold:false, italic:false }
};

/* ========= layout / sizing ========= */
function measureTopbar(){
  const r = topbar.getBoundingClientRect();
  document.documentElement.style.setProperty('--topbar-h', `${r.height}px`);
  document.documentElement.style.setProperty('--sidebar-top', `${r.height}px`);
}
function resizeCanvases(){
  dpr = window.devicePixelRatio || 1;
  const r = inner.getBoundingClientRect();
  [grid,paper,hud].forEach(c=>{
    c.width = Math.round(r.width * dpr);
    c.height = Math.round(r.height * dpr);
    const cxt = c.getContext('2d');
    cxt.setTransform(1,0,0,1,0,0);
    cxt.scale(dpr, dpr);
    c.style.width = r.width+'px';
    c.style.height = r.height+'px';
  });
  drawGrid();
}
function setZoom(v){
  zoom = clamp(v, .5, 3);
  inner.style.transform = `scale(${zoom}) translate(${off.x}px, ${off.y}px)`;
  $('#zoomPct').textContent = Math.round(zoom*100)+'%';
  drawGrid();
}

/* ========= grid ========= */
function mm2px(mm){ return mm * 96/25.4; } // CSS px
function drawGrid(){
  const show = state.grid.show;
  gtx.clearRect(0,0,grid.width/dpr, grid.height/dpr);
  if(!show) return;
  const pitch = mm2px(state.grid.pitchMM)*zoom;  // ズーム連動
  const w = grid.width/dpr, h = grid.height/dpr;
  gtx.strokeStyle = state.grid.color;
  gtx.lineWidth = 1;
  gtx.globalAlpha = .35;
  gtx.beginPath();
  for(let x=0; x<=w; x+=pitch){ gtx.moveTo(x+.5,0); gtx.lineTo(x+.5,h); }
  for(let y=0; y<=h; y+=pitch){ gtx.moveTo(0,y+.5); gtx.lineTo(w,y+.5); }
  gtx.stroke();
  gtx.globalAlpha = 1;
}

/* ========= toolbar / active visuals ========= */
function setActive(name){
  tool = name;
  Object.entries(tools).forEach(([k,el])=>{
    if(!el.classList.contains('tool')) return;
    el.classList.toggle('active', k===name || (k==='gear' && panel.classList.contains('show')));
  });
  // テキストレイヤの操作性
  textLayer.style.pointerEvents = (tool==='text' || tool==='hand' || tool==='eraser') ? 'auto':'none';
  buildPanel();
}
Object.values(tools).forEach(el=>{
  if(!el || !el.dataset) return;
  if(el.dataset.tool){
    on(el,'click',()=>setActive(el.dataset.tool));
  }
});
on(tools.gear,'click',()=>{
  panel.classList.toggle('show');
  setActive(tool);
});
on(tools.collapse,'click',()=>{
  const sb = sidebar;
  const collapsed = sb.dataset.col==='1';
  sb.dataset.col = collapsed ? '0':'1';
  sb.style.height = collapsed ? '' : '45px';
  sb.style.overflow = 'hidden';
  // アイコン回転
  const svg = tools.collapse.querySelector('svg');
  svg.style.transform = collapsed ? 'rotate(0deg)':'rotate(180deg)';
  svg.style.transition = '.2s';
});

/* ========= panel (draggable) ========= */
const panel = $('#panel'), panelBody=$('#panelBody'), panelTitle=$('#panelTitle');
$('#panelClose').onclick = ()=>{ panel.classList.remove('show'); setActive(tool); };
(function makeDraggable(){
  let dragging=false, sx=0, sy=0, px=0, py=0;
  const handle = panel.querySelector('.handle');
  on(handle,'pointerdown',e=>{
    dragging=true; sx=e.clientX; sy=e.clientY;
    const r = panel.getBoundingClientRect(); px=r.left; py=r.top;
    panel.setPointerCapture?.(e.pointerId);
  });
  on(window,'pointermove',e=>{
    if(!dragging) return;
    panel.style.left = (px + (e.clientX-sx))+'px';
    panel.style.top  = (py + (e.clientY-sy))+'px';
  });
  on(window,'pointerup',()=>dragging=false);
})();

/* ========= panel content ========= */
function buildPanel(){
  const t = tool;
  panelTitle.textContent =
    t==='pen'   ? 'ペン設定' :
    t==='marker'? 'マーカー設定' :
    t==='eraser'? '消しゴム設定' :
    t==='text'  ? 'keyboard 設定' :
    t==='hand'  ? 'パン設定' : '設定';

  const P = [];
  const range = (id,label,min,max,step,val)=>
    `<div class="row"><label>${label}</label><input id="${id}" type="range" min="${min}" max="${max}" step="${step}" value="${val}"><span class="badge">${id.includes('alpha')?(val*100|0)+'%':val+'px'}</span></div>`;

  if(t==='pen' || t==='marker'){
    const s = state[t];
    P.push(`<div class="row"><label>色</label><input type="color" id="clr" value="${s.color}"></div>`);
    P.push(range('size','太さ',1,64,1,s.size));
    P.push(range('alpha','不透明度',0,1,0.01,s.alpha));
    P.push(`<div class="row"><label>直線</label>
      <label class="pill"><input type="checkbox" id="line" ${s.line?'checked':''}> 直線モード（15°刻み）</label></div>`);
    if(t==='marker'){
      P.push(`<div class="row"><label>端の形</label>
        <select id="cap">
          <option value="butt" ${s.cap==='butt'?'selected':''}>□ 角</option>
          <option value="round" ${s.cap==='round'?'selected':''}>● 丸</option>
        </select></div>`);
    }
    P.push(`<div class="group">グリッド</div>
      <div class="row"><label>表示</label><input id="gridShow" type="checkbox" ${state.grid.show?'checked':''}></div>
      <div class="row"><label>ピッチ</label>
        <select id="gridPitch">
          <option value="5" ${state.grid.pitchMM===5?'selected':''}>5mm</option>
          <option value="10" ${state.grid.pitchMM===10?'selected':''}>10mm</option>
        </select>
        <input type="color" id="gridColor" value="${state.grid.color}">
      </div>`);
  }
  if(t==='eraser'){
    const s = state.eraser;
    P.push(range('esize','消し幅',4,64,1,s.size));
  }
  if(t==='text'){
    const s = state.text;
    P.push(range('tsize','文字サイズ',10,120,1,s.size));
    P.push(`<div class="row"><label>色</label><input type="color" id="tcolor" value="${s.color}"></div>`);
    P.push(`<div class="row"><label>スタイル</label>
      <label class="pill"><input type="checkbox" id="tbold" ${s.bold?'checked':''}> 太字</label>
      <label class="pill"><input type="checkbox" id="titalic" ${s.italic?'checked':''}> 斜体</label>
    </div>`);
    P.push(`<div class="row"><button class="btn" id="addText">テキストを追加</button>
      <button class="btn" id="delText">枠ごと削除</button></div>`);
  }
  panelBody.innerHTML = P.join('');

  /* wire */
  const B = id=>panelBody.querySelector('#'+id);
  if(t==='pen' || t==='marker'){
    const s = state[t];
    B('clr').oninput = e=> s.color = e.target.value;
    B('size').oninput = e=>{ s.size = +e.target.value; e.target.nextElementSibling.textContent = s.size+'px'; };
    B('alpha').oninput = e=>{ s.alpha = +e.target.value; e.target.nextElementSibling.textContent = (s.alpha*100|0)+'%'; };
    B('line').onchange = e=> s.line = e.target.checked;
    if(t==='marker'){ B('cap').onchange = e=> s.cap = e.target.value; }
    B('gridShow').onchange = e=>{ state.grid.show = e.target.checked; drawGrid(); };
    B('gridPitch').onchange = e=>{ state.grid.pitchMM = +e.target.value; drawGrid(); };
    B('gridColor').oninput = e=>{ state.grid.color = e.target.value; drawGrid(); };
  }
  if(t==='eraser'){
    B('esize').oninput = e=>{ state.eraser.size = +e.target.value; e.target.nextElementSibling.textContent = state.eraser.size+'px'; };
  }
  if(t==='text'){
    const s = state.text;
    B('tsize').oninput = e=>{ s.size = +e.target.value; e.target.nextElementSibling.textContent = s.size+'px'; };
    B('tcolor').oninput = e=> s.color = e.target.value;
    B('tbold').onchange = e=> s.bold = e.target.checked;
    B('titalic').onchange = e=> s.italic = e.target.checked;
    B('addText').onclick = addTextBox;
    B('delText').onclick = deleteSelectedTextBox;
  }
}

/* ========= drawing ========= */
function setStrokeForTool(){
  if(tool==='pen' || tool==='marker'){
    const s = state[tool];
    ctx.globalAlpha = s.alpha;
    ctx.strokeStyle = s.color;
    ctx.lineWidth = s.size;
    ctx.lineJoin = 'round';
    ctx.lineCap = (tool==='marker') ? s.cap : 'round';
  }else if(tool==='eraser'){
    ctx.globalCompositeOperation = 'destination-out';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = state.eraser.size;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
  }
}
function restoreComposite(){
  if(tool==='eraser') ctx.globalCompositeOperation = 'source-over';
}
function pos(e){
  const r = paper.getBoundingClientRect();
  return { x:(e.clientX - r.left)/zoom, y:(e.clientY - r.top)/zoom };
}

/* live straight HUD */
function showHUD(x,y,deg){
  angleBadge.style.left = x+'px';
  angleBadge.style.top = y+'px';
  angleBadge.textContent = `${deg}°`;
  angleBadge.style.display = 'block';
}
function hideHUD(){ angleBadge.style.display = 'none'; htx.clearRect(0,0,hud.width/dpr,hud.height/dpr); }

on(window,'keydown',e=>{ if(e.key==='Shift') shift = true; });
on(window,'keyup',e=>{ if(e.key==='Shift') shift = false; hideHUD(); });

on(paper,'pointerdown',e=>{
  if(tool==='hand'){ // pan
    panning = true; start = {x:e.clientX, y:e.clientY, ox:off.x, oy:off.y};
    paper.setPointerCapture?.(e.pointerId); return;
  }
  if(tool==='text'){ return; } // テキストはdiv操作
  if(!['pen','marker','eraser'].includes(tool)) return;

  paper.style.touchAction = 'none';
  paper.setPointerCapture?.(e.pointerId);
  drawing = true;
  start = last = pos(e);
  setStrokeForTool();
  ctx.beginPath();
  ctx.moveTo(last.x, last.y);
});

on(paper,'pointermove',e=>{
  if(panning && tool==='hand'){
    const dx = (e.clientX - start.x)/zoom, dy = (e.clientY - start.y)/zoom;
    off.x = start.ox + dx; off.y = start.oy + dy;
    inner.style.transform = `scale(${zoom}) translate(${off.x}px, ${off.y}px)`;
    return;
  }
  if(!drawing) return;
  const p = pos(e);
  const straight = (tool==='pen' && state.pen.line) || (tool==='marker' && state.marker.line) || shift;

  if(straight){
    // プレビューはHUDで、確定はpointerup
    htx.clearRect(0,0,hud.width/dpr,hud.height/dpr);
    htx.strokeStyle = (tool==='marker')? state.marker.color : state.pen.color;
    htx.globalAlpha = (tool==='marker')? state.marker.alpha : state.pen.alpha;
    htx.lineWidth  = (tool==='marker')? state.marker.size  : state.pen.size;
    htx.lineCap    = (tool==='marker')? state.marker.cap   : 'round';
    htx.beginPath();
    const dx = p.x - start.x, dy=p.y - start.y;
    const deg = Math.round(Math.atan2(dy,dx)*180/Math.PI/15)*15;
    const rad = deg*Math.PI/180;
    const len = Math.hypot(dx,dy);
    const sx = start.x + Math.cos(rad)*len;
    const sy = start.y + Math.sin(rad)*len;
    htx.moveTo(start.x, start.y); htx.lineTo(sx, sy); htx.stroke();
    showHUD(e.clientX, e.clientY, deg);
  }else{
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    last = p;
  }
});

on(paper,'pointerup',e=>{
  if(panning){ panning=false; return; }
  if(!drawing) return;
  const p = pos(e);
  const straight = (tool==='pen' && state.pen.line) || (tool==='marker' && state.marker.line) || shift;

  if(straight){
    const dx = p.x - start.x, dy=p.y - start.y;
    const deg = Math.round(Math.atan2(dy,dx)*180/Math.PI/15)*15;
    const rad = deg*Math.PI/180;
    const len = Math.hypot(dx,dy);
    const sx = start.x + Math.cos(rad)*len;
    const sy = start.y + Math.sin(rad)*len;
    ctx.beginPath(); setStrokeForTool();
    ctx.moveTo(start.x,start.y); ctx.lineTo(sx,sy); ctx.stroke();
    hideHUD();
  }
  drawing=false; restoreComposite();
  pushHistory();
});

on(paper,'pointercancel',()=>{ drawing=false; panning=false; restoreComposite(); hideHUD(); });

/* ========= text boxes ========= */
let selectedText=null;
function addTextBox(){
  const s = state.text;
  const box = document.createElement('div');
  Object.assign(box.style, {
    position:'absolute', left:'120px', top:'120px', minWidth:'40px', minHeight:'28px',
    color:s.color, fontSize:s.size+'px',
    fontWeight:s.bold?'700':'400', fontStyle:s.italic?'italic':'normal',
    border:'1px dashed rgba(255,255,255,.25)', borderRadius:'8px',
    padding:'6px 8px', background:'transparent', cursor:'text'
  });
  box.contentEditable = 'true';
  box.textContent = 'テキスト';
  box.dataset.type='textbox';
  const handle = document.createElement('div');
  Object.assign(handle.style,{position:'absolute', left:'-10px', top:'-10px', width:'10px', height:'10px', borderRadius:'50%', background:'#ccc', cursor:'move'});
  box.appendChild(handle);
  textLayer.appendChild(box);
  textLayer.style.pointerEvents='auto';

  // select
  box.addEventListener('pointerdown',e=>{
    selectedText=box;
    if(e.target===handle){
      // drag
      const r = box.getBoundingClientRect();
      const s = {x:e.clientX, y:e.clientY, l:r.left, t:r.top};
      function mv(ev){
        const dx=(ev.clientX-s.x)/zoom, dy=(ev.clientY-s.y)/zoom;
        box.style.left = (parseFloat(box.style.left||0)+dx)+'px';
        box.style.top  = (parseFloat(box.style.top||0)+dy)+'px';
        s.x=ev.clientX; s.y=ev.clientY;
      }
      function up(){ window.removeEventListener('pointermove',mv); window.removeEventListener('pointerup',up); pushHistory(); }
      window.addEventListener('pointermove',mv); window.addEventListener('pointerup',up);
      ev.preventDefault();
    }
  });
  box.addEventListener('input',()=>{ if(box.textContent==='') box.textContent=''; });
  box.addEventListener('blur',()=>{ if(box.textContent.trim()==='') { box.remove(); pushHistory(); } else pushHistory(); });

  pushHistory();
}
function deleteSelectedTextBox(){
  if(selectedText){ selectedText.remove(); selectedText=null; pushHistory(); }
}

/* ========= history ========= */
function snapshot(){
  // 画像レイヤ
  const w = paper.width, h=paper.height;
  const img = paper.toDataURL('image/png');
  // テキストHTML
  const html = textLayer.innerHTML;
  return {img, html, w, h};
}
function restore(snap){
  return new Promise(res=>{
    const img = new Image();
    img.onload=()=>{
      // いったんクリア
      ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
      ctx.clearRect(0,0,paper.width/dpr,paper.height/dpr);
      ctx.drawImage(img,0,0);
      textLayer.innerHTML = snap.html;
      res();
    };
    img.src = snap.img;
  });
}
function pushHistory(){
  const s = snapshot();
  hist.push(s);
  while(hist.length>HIST_MAX) hist.shift();
  redoStack.length=0;
}
$('#undoBtn').onclick = async ()=>{
  if(hist.length<=1) return;
  redoStack.push(hist.pop());
  const prev = hist[hist.length-1];
  await restore(prev);
};
$('#redoBtn').onclick = async ()=>{
  if(!redoStack.length) return;
  const snap = redoStack.pop();
  hist.push(snap);
  await restore(snap);
};

/* ========= topbar actions ========= */
$('#zoomOut').onclick=()=>setZoom(zoom-0.1);
$('#zoomIn').onclick =()=>setZoom(zoom+0.1);
$('#zoomPct').onclick=()=>setZoom(1);

$('#printBtn').onclick = ()=>window.print();

$('#pngBtn').onclick = ()=>{
  const url = paper.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url; a.download = 'note.png'; a.click();
};

$('#shareBtn').onclick = async ()=>{
  try{
    if(navigator.share){
      const blob = await new Promise(r=>paper.toBlob(r));
      const file = new File([blob],'note.png',{type:'image/png'});
      await navigator.share({title:'Note', files:[file]});
    }else{
      $('#pngBtn').click();
    }
  }catch{}
};

/* ========= boot ========= */
function boot(){
  measureTopbar();
  resizeCanvases();
  setZoom(1);
  setActive('pen');
  panel.classList.add('show'); // 起動時は見えるように
  buildPanel();
  // 初期スナップ
  pushHistory();
}
on(window,'resize',()=>{ measureTopbar(); resizeCanvases(); });
on(document,'visibilitychange',()=>{ measureTopbar(); resizeCanvases(); });
boot();
</script>
</body>
</html>
